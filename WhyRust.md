# 前沿技术研究 & 浏览器内WebAssembly的应用(Rust)初步探究

> WebAssembly是一种新的`编码`方式，可以在`现代`的网络浏览器中运行 － 它是一种`低级的类汇编语言`，具有紧凑的`二进制`格式，可以接近`原生`的性能运行，并为诸如C / C ++等语言提供一个编译目标，以便它们可以在Web上运行。它也被设计为可以与JavaScript共存，允许两者一起工作。

上面是MDN(中文)对`WebAssembly`技术的一个概要介绍。关键词我已经标注，我们的学习将从这些关键词开始。

首先，简要地理解一下上面的一段话：

1. 从其他语言编译到二进制格式的文件(`.wasm`)中
2. 该二进制格式的文件可以运行在现代浏览器中
3. 性能接近原生
4. 与`JavaScript`共存

备注【⚠️】：该技术不一定只被应用于浏览器中，随着`JavaScript`能力的扩展，该技术可以有无限的想象空间。

## 关键词

我们从上面的描述，再提取一下关键词。这些关键词是我们进一步学习`WabAssembly`技术的关键。（✅内容为必学内容，其余为选学内容 ）

- [x] JavaScript
- [x] 现代浏览器
- [x] 编译原理
- [x] WebAssembly
- [ ] Web Worker
- [ ] ReactiveX

## 1. JavaScript Or Typescript

![语言类型](./wander/语言类型.png)

首先，你真的了解`JavaScript`吗？

### 静态类型语言 vs 动态类型语言

- 静态类型 编译/解释时不允许变量类型不确定
- 动态类型 编译/解释时允许变量的不确定性

`JavaScript`是一门动态类型的语言。曾经 ，我们一个`var`变量就吃遍了所有浏览器，有时甚至连`var`都不用。动态类型语言在编译期无法确定变量类型，需要在运行时动态地获取变量类型并开辟对应的内存空间。理论上，丢失了编译期的优化，动态类型语言的执行效率要低很多。

而常见的比较对象`Java`，在执行前有一个编译过程。将`.java`文件编译为`.class`文件，最后由虚拟机执行`.class`文件。

编译后的`二进制文件`更接近硬件描述语言，执行效率更高。

### 解释型语言 vs 编译型语言

- 解释型 边解释边运行，这里的解释相当于编译
- 编译型 编译后运行

比如`Java`的经典宣传语`一次编译，到处运行`。指的就是编译后在任意平台，只要安装好虚拟机，就可以跑起来！而`JavaScript`则依赖于解释平台，不同的浏览器有不同的内核，我们熟知的`V8`就是可以处理`JavaScript`的解释和运行的内核平台。

实际上，由于`V8`被扩展到了`PC`平台(Node、Electron等)，我们也可以说`JavaScript`可以到处运行。只不过它的运行仍然依赖于解释它的内核。

------

那么作为一个解释型的动态类型语言，`JavaScript`就真的很慢吗？答案是否定的。

在现代浏览器内，我们已经可以做复杂的图像应用、富文本应用，可以处理大量的数据，可以完成很酷炫的UI交互效果，这证明了`JavaScript`并没有想象中那么慢。而且，在现代引擎的加持下，`JavaScript`已经不仅仅是`解释`执行了，还有一些`AOT`的编译操作。

另外，为什么我们有了`JavaScript`之后，还需要`Typescript`? 类型确定！

1. 让解释器更懂我们的代码
2. 开发人员更少犯错

----

或者，在页面寻找更多的可能性 - `wasm`

## 现代浏览器

![现代浏览器架构](./wander/现代浏览器架构.png)

我们熟悉的`V8`，处于这个架构的`Render Process`层。我们先来看一下，现代浏览器可以做的一些事情。

- 更快、性能更好。当然硬件资源占用也更多。
- `PWA`应用。模拟原生应用的方式。
- `Web Worker`技术。模拟多线程应用的方式。
- `Wasm`技术。模拟原生性能。
- `WebGL`技术。模拟原生渲染技术。
- ...

### 性能问题？

![V8引擎编译过程](./wander/V8引擎编译过程.png)

那些与应用性能相关的软硬件技术。

- 内存。应用对内存的访问是最快的，硬件上，内存颗粒的种类、内存缓存架构、容量都影响到内存的速度，内存不够时，可能会造成应用崩溃，或者计算机会开辟硬件空间作为虚拟内存，降低运行速度；软件上，我们重要的数据，访问内存是比读取文件更快的。比如，通常内存数据库就比文件数据库访问更快。
- 多线程。串行处理意见事和并行处理一件事，对同一个人来说，是效率是否减半的问题。对计算机也是，多线程技术充分利用了CPU的时钟周期，依赖操作系统的高效调度算法，让我们可以同时处理多项事项。
- AOT(Ahead-Of-Time)。预编译技术让我们真实执行的代码更贴近硬件系统，使得运行时更快，通常这些编译产物都是二进制文件。二进制文件是更紧凑的文件，计算机读写二进制文件也更快。
- Cache。硬件系统有多级缓存架构，软件系统也会有缓存架构，缓存让我们更快得到目标数据。
- ...

`V8`引擎通常的执行流程(机器码是一种汇编语言)

1. 读取并解释/编译`JavaScript`文件
2. 运行编译产物(内核通常基于C/C++)，若同类型参数/输出在某函数块上反复调用，可能被二次编译
3. 二次编译产物是基于上一次编译产物的优化后的结果，更加接近硬件系统，执行效率更高。
4. 当然，若在后续执行过程中发现二次编译产物的参数类型有变化，可能会回退到初次产物中执行。

⚠️ 除了这个主流程之外，大部分内置函数以及`for`循环在`V8`上也有专门的优化(预编译AOT的字节码)

因此，在解释器和预编译上，现代浏览器是做了很多工作，真实跑在浏览器上的，可能是编译完的字节码。自然要快很多。

### 解析和执行

![webkit渲染引擎工作流程](./wander/webkit渲染引擎工作流程.png)

目前DOM接口的访问还只能通过`JavaScript`进行，很多其它语言(包括Rust)操作DOM都是通过桥接一层，底层还是调用的原生DOM的API。因此，这一块我们还不能做一些好的优化。

⚠️ 随着`WebAssembly`技术的发展，相信会有底层直接实现对接的方式(不经过`JavaScript`)

----

`JavaScript`也是一门单线程的语言(避免多线程DOM/BOM API调用造成渲染、计算的错乱)。

1. 利用`WebAssembly`技术可以替换一部分耗时的`JavaScript`代码，在语言上实现加速
2. 利用`Event Loop`实现代码异步执行，避免影响`UI`渲染
3. 利用`Web Worker`技术实现模拟的多线程`JavaScript`代码技术。

## 编译原理

我们的自然语言(如中文)，有很多语法和词法规则，计算机语言也是一样的，我们在解释/翻译/运行某一门语言时，其实就是在用词法和语法生成语言。通常，编译是这么一个过程(以Rust编译Wasm为例)。

![编译器原理](./wander/编译器原理.png)

其中`Token`生成这一步有多种方式，但都是基于语言的`词法`、`语法`、`语义`来确定的，到最后生成目标代码时也是一样的。

![语法树示例](./wander/语法树示例.png)

1. Rust语言规则解析，生成相关的标记(`tokens`)，也称为词法解析。
2. 把我们获取到的`tokens`转译为抽象语法树(AST)，也称为语法解析和语义解析，因为这一步我们要分析一些语义上的东西，让构成的抽象语法树合法。
3. 转译。这一步我们可以用和上面两步逆向的方式，把我们基于`Rust`的抽象语法树，转译为一门新的语言。

编译器也分为前端和后端。

1. 前端。词法分析、语法分析、语义分析等，并生成中间代码。
2. 后端。中间代码优化、目标代码生成等。

关联知识

1. [the-super-tiny-compiler](https://github.com/jamiebuilds/the-super-tiny-compiler)
2. [emscripten](https://emscripten.org/)
3. [DSL](https://book.douban.com/subject/21964984/)

## WebAssembly

终于到了我们的目标技术。上面的一些罗列有没有让你发晕？但我们的`wasm`确是以上面提到的技术作为基础的。

![wasm技术链条](./wander/wasm技术链条.png)

到现在，我们看这个图就更清晰了。为何一门语言能够编译为`wasm`文件并被浏览器利用?

1. 不同语言的特性不同，我们主要利用`Rust`安全、高性能以及工具链较为完善的优势
2. 编译。这一步我们有`wasm-pack`。当然这个项目底层还依赖了不同的模块，以充分利用各个语言特性、实现桥接等。它本身还提供了`wasm`优化功能(来自另一个库)。
3. `emscripten`是另一个很出名的库，他是以编译`asm.js`为目的出现的，如今已成为一个编译到`wasm`的重要工具链。
4. `wasm`。也就是字节码(类似汇编的语言)，让我们充分利用AOT的能力，减少了`V8`解释和编译`JavaScript`的一个过程。
5. 现代浏览器。各种高性能的引擎。

当然，利用`TypeScript`提供的类型确定性，我们也可以让`V8`更好地为我们服务。

----

业界对`wasm`的使用，大概有两种

1. 直接从后台加载`.wasm`文件。
2. 与`web worker`结合使用。

![利用wasm和worker技术提升应用体验](./wander/利用wasm和worker技术提升应用体验.png)

在使用场景上，基本上现在的`wasm`在企业级应用上，只有重CPU的应用。有这么一些场景

1. 游戏运算
2. 算法提速
3. 3D
4. 加密解密算法

虽然目前能够利用这种高性能技术的场景比较少，但`wasm`正式发布也才三四年时间，留给我们可以探索和想象的空间也很大

1. 高性能的DOM/BOM接口
2. 模拟的多线程方案
3. 文件读写方案
4. ...

上述这些问题一旦被解决，`wasm`将迎来一波爆发。或许，未来的浏览器上，`JavaScript`代码不会占到`95%`以上？

----

当然，一个针对`Rust`的`wasm`产物的`benchmark`是必要的，这对我们的选择有一定的指导意义。

![性能对比测试](./wander/性能对比测试.jpeg)
⚠️ 声明

1. 笔者属于刚入门`Rust`的能力级别，`wasm`产物可能因此受到影响
2. [项目测试](https://github.com/WanderHuang/rustin)因人而异，不作为唯一标准
3. 项目还处于进行中，当前测试结果不作为最终结果

从我的测试结果来看

1. 基本数字数组的排序算法，两者相差不大，甚至`JavaScript`得益于`V8`的内置优化，会更胜一筹。
2. 字符串运算/算法运算，`Wasm`至少有`5`倍的性能提升，这一块的尝试还是值得的。

----

代码就不必贴了(【代码演示】)，有兴趣的同学可以在[这里](https://github.com/WanderHuang/rustin)看一下`https://github.com/WanderHuang/rustin`



